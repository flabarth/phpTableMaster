<?php

namespace phpTableMaster\Reader;

use phpTableMaster\Element\Table;
use phpTableMaster\Element\Header;
use phpTableMaster\Element\Column;
use phpTableMaster\Element\Row;
use phpTableMaster\Interfaces\CellI;
use phpTableMaster\Util\TableUtils;
use phpTableMaster\Util\DateMaster;

/**
 * Description of ArrayReader
 *
 * @author Flavo
 */
class ArrayReader {
    
    // TODO Maybe make $array and $params distinct classes instead of attributes.
    // TODO Add support to arrays with no "headers" (indexes).
    // TODO Additional rows by condition. If condition is met in the prev row, add a new row below.
    // TODO Additional attributes for row BY CONDITION.
    
    /**
     * String used to define a variable inside the
     * ArrayReader class.
     * @var string
     */
    private const DELIMITER_VARIABLE = "%%";
    
    /**
     * String used to define the begin of a function
     * substring.
     * @var string
     */
    private const DELIMITER_BEGIN_FUNCTION = "{{";
    
    /**
     * String used to define the end of a function
     * substring.
     * @var string
     */
    private const DELIMITER_END_FUNCTION = "}}";
    
    /**
     * String used when a value is not set.
     * @var string
     */
    private const DEFAULT_EMPTY_VALUE = "";
    
    /** @var array **/
    private $array = [];
    
    /** @var array **/
    private $params = [];
    
    /** @var phpTableMaster\Element\Table **/
    private $table;
    
    /** @var string **/
    private $rowIndex = "";
    
    /** 
     * The class needs to "rasterize" DateTime objects
     * in order to work properly. This format will be the
     * output of all DateTimes in the dataset.
     * @var string
    **/
    private $dateFormat = DateMaster::FORMAT_US_TIME_MILLISECOND;
    
    /** @var bool **/
    private $convertDate = false;
    
    public function __construct(array $array, $params) {
        
        $this->array = $array;
        $this->params = $params;
        
    }
    
    /**
     * Sets the row index. The row index will be used to
     * indetify the row in many ways and will become the
     * id of the row. You mays use variables from the
     * dataset with "%%".
     * @param string $rowIndex
     * @return void
     */
    public function setRowIndex(string $rowIndex) : void {
        
        $this->rowIndex = $rowIndex;
        
    }
    
    /**
     * Sets the date format for conversion. It is advisable
     * to use a DateMaster constant.
     * @param string $dateFormat
     * @return void
     */
    public function setDateFormat(string $dateFormat) : void {
        
        $this->dateFormat = $dateFormat;
        
    }
    
    /**
     * When true, converts all date strings in the dataset
     * to $dateFormat.
     * @param bool $convertDate
     * @return void
     */
    public function setConvertDate(bool $convertDate) : void {
        
        $this->convertDate = $convertDate;
        
    }
    
    /**
     * Mounts a table object based on the given properties.
     * The table will be only built once for every object
     * of ArrayReader. In order to rebuild the table object,
     * use the destroyTable() method.
     * @return Table
     */
    public function getTable() : Table {
        
        if(!isset($this->table)){
        
            $this->table = new Table();

            $numberOfRows = $this->getArrayRowsCounter();
            $numberOfColumns = $this->getParamsCounter();
            
            $this->table->create($numberOfRows, $numberOfColumns);
            
            $this->array = TableUtils::rasterizeAssocArrayDateTime($this->array, $this->dateFormat);
            $this->convertDate ? TableUtils::convertAssocArrayDate($this->array, $this->dateFormat) : null;
            
            $this->mountTableHeader();
            $this->mountTableBody();
            
        }
        
        return $this->table;
        
    }
    
    /**
     * Destroys the table object generated by ArrayReader.
     * Use this method in order to rebuild the table
     * object through getTable().
     * @return void
     */
    public function destroyTable() : void {
        
        unset($this->table);
        
    }
    
    /**
     * Builds the table object columns.
     * @return void
     */
    public function mountTableHeader() : void {
        
        $arrayHeader = $this->getArrayHeader();
        
        foreach($arrayHeader as $columnNumber => $index) {
            
            $column = $this->table->getColumn($columnNumber);
            $header = $column->getHeader();
            
            $this->setHeaderContent($header, $index);
            $this->setColumnWidth($column, $index);
            
        }
        
    }
    
    /**
     * Builds the table object rows.
     * @return void
     */
    public function mountTableBody() : void {
        
        foreach($this->array as $rowNumber => $row) {
            
            $rowObj = $this->table->getRow($rowNumber);
            
            $this->setRowId($row, $rowObj);
            
            foreach($this->table->getColumns() as $columnNumber => $column) {
                    
                $numericParams = array_keys($this->params);
                $index = $numericParams[$columnNumber];

                $cell = $this->table->getCell($rowNumber, $columnNumber, true);
                
                if(!isset($this->params[$index]["content"]) && isset($row[$index])) {
                    
                    $this->params[$index]["content"] = self::DELIMITER_VARIABLE . $index . self::DELIMITER_VARIABLE;
                    
                }
                
                $this->setCellProperty($cell, $row, $index);
                    
            }
            
        }
        
    }
    
    /**
     * Returns the number of header in the params
     * array.
     * @return int
     */
    public function getParamsCounter() : int {
        
        return count($this->params);
        
    }
    
    /**
     * Returns number of rows from the array.
     * @return int
     */
    public function getArrayRowsCounter() : int {
        
        return count($this->array);
        
    }
    
    /**
     * Returns the header (associative indexes) from params.
     * @return array
     */
    public function getArrayHeader() : array {
        
        return array_keys($this->params);
        
    }
    
    /**
     * Sets cell properties via magic method.
     * @param CellI $cell
     * @param array $row
     * @param string $index
     * @return void
     */
    private function setCellProperty(CellI $cell, array $row, string $index) : void {
        
        foreach($this->params[$index] as $property => $value) {
            
            // TODO Improve the heuristic.
            /**
             * I feel like there is too much code when I make a selection
             * for specific properties. Must find a way to make it as
             * flexible as possible, without repeating method calls in the
             * code. It works, but it feels "wrong" and "ugly".
             */
            
            if($property == "data") {
                
                foreach($value as $data => &$dataValue) {
                    
                    $dataValue = $this->translateConditions($dataValue, $this->params[$index], $data, $index, $row);
                    $dataValue = $this->replaceStringVariables($dataValue, $row);
                    $dataValue = $this->applyPHPFunctions($dataValue);
                    
                }
                
            } else {
                
                $value = $this->translateConditions($value, $this->params, $property, $index, $row);
                $value = $this->replaceStringVariables($value, $row);
                $value = $this->applyPHPFunctions($value);
                
            }
            
            $cell->__set($property, $value);
            
        }
        
    }
    
    /**
     * Sets the header content (title). The title of
     * the header will be either its own name, or the
     * title parameter.
     * @param string $content
     * @return string
     */
    private function setHeaderContent(Header $header, string $index) : void {
        
        if(isset($this->params[$index]["title"])) {
                
            $index = $this->params[$index]["title"];
                
        }
        
        $header->setContent($index);
        
    }
    
    /**
     * Sets the id of the row object.
     * @param array $dataRow
     * @param Row $row
     * @return void
     */
    private function setRowId(array $dataRow, Row $row) : void {
        
        $rowId = $this->replaceStringVariables($this->rowIndex, $dataRow);
        
        $row->setId($rowId);
        
    }
    
    /**
     * Sets the column width if param width is set.
     * @param Column $column
     * @param string $index
     * @return void
     */
    private function setColumnWidth(Column $column, string $index) : void {
        
        if(isset($this->params[$index]["width"])) {
                
            $column->setWidth($this->params[$index]["width"]);
            
        }
        
    }
    
    /**
     * Recursively iterate through a multilevel associative array
     * replacing all occurences of variables by their respective
     * values.
     * @param type $params
     * @return type
     */
    private function replaceArrayVariables(array $params, array $row) : array {
        
        foreach($params as $key => $param){
            
            if(is_array($param)){
                
                $params[$key] = $this->replaceArrayVariables($param, $row);
                
            }else{
                
                $params[$key] = $this->replaceStringVariables($param, $row);
                    
            }
            
        }
        
        return $params;
        
    }
    
    /**
     * Replaces variables by their respective value in the row
     * inside a string.
     * @param string $string
     * @param array $row
     * @return string
     */
    private function replaceStringVariables(string $string, array $row) : string {
        
        $variables = TableUtils::extractFromString($string, self::DELIMITER_VARIABLE, self::DELIMITER_VARIABLE);
        
        foreach($variables as $variable) {
            
            if(isset($row[$variable])) {
            
                $string = str_replace(self::DELIMITER_VARIABLE . $variable . self::DELIMITER_VARIABLE, $row[$variable], $string);
            
            }

        }
        
        return $string;
        
    }
    
    /**
     * Apply functions in function subtring, based on delimiters.
     * @param string $string
     * @return string
     */
    private function applyPHPFunctions(string $string) : string {
        
        while((strpos($string, self::DELIMITER_BEGIN_FUNCTION) !== false) && (strpos($string, self::DELIMITER_END_FUNCTION) !== false)) {
        
            $functions = TableUtils::extractChunkFromString($string, self::DELIMITER_BEGIN_FUNCTION, self::DELIMITER_END_FUNCTION);

            foreach($functions as $functionKey => $function) {

                $subFunctions = TableUtils::extractInnerSequenceFromString($function, self::DELIMITER_BEGIN_FUNCTION, self::DELIMITER_END_FUNCTION);

                foreach($subFunctions as &$subFunction) {

                    if(strpos($subFunction, "::") !== false) {

                        $class = strstr($subFunction, "::", true);
                        $method = TableUtils::extractFromString($subFunction, "::", "(");
                        $variable = TableUtils::extractFromString($subFunction, "(", ")");
                        $variable = explode(",", $variable[0]);
                        $subFunctionResult = call_user_func_array([$class, $method[0]], $variable);

                    } else {

                        $method = strstr($subFunction, "(", true);
                        $variable = TableUtils::extractFromString($subFunction, "(", ")");
                        $variable = explode(",", $variable[0]);
                        $subFunctionResult = call_user_func_array($method, $variable);

                    }

                    $string = str_replace(self::DELIMITER_BEGIN_FUNCTION . $subFunction . self::DELIMITER_END_FUNCTION, $subFunctionResult, $string);

                }

            }
        
        }
        
        return $string;
        
    }
    
    /**
     * This method will translate the "if" parameter into
     * the real value of the param, based on its conditions
     * for a given row.
     * @param mixed $original
     * The original value of the value to be translated.
     * @param array $params
     * @param string $property
     * @param string $index
     * @param array $row
     * @return mixed
     */
    private function translateConditions($original, array $params, string $property, string $index, array $row) {
        
        $result = $original;
        
        if(is_array($result)) {
            
            if(isset($result["if"])) {

                $result = $this->applyConditions($result["if"], $index, $row);

            } else if(isset($result["switch"])) {
                
                foreach($result["switch"] as $condKey => $condition) {
                    
                    $result = $this->applyConditions($condition, $index, $row);
                    
                    if($result == $condition["then"] || (isset($condition["else"]) && $result == $condition["else"])) {
                        
                        break;
                        
                    }
                    
                }
                
            }

        }
        
        return $result;
        
    }
    
    /**
     * Reads a condition array and returns a string result based on
     * the result.
     * @param array $condition
     * @param string $index
     * @param array $row
     * @return string
     */
    private function applyConditions(array $condition, string $index, array $row) : string {
        
        $result = $row[$index];
        $conditionTrue = false;
        
        if(isset($condition["equals"])) {
            
            if($condition["equals"] == $row[$index]) {
                
                $result = $condition["then"];
                $conditionTrue = true;
                
            }
            
        } else if (isset($condition["not"])) {
            
            if($condition["not"] !== $row[$index]) {
                
                $result = $condition["then"];
                $conditionTrue = true;
                
            }
            
        }
        
        if(isset($condition["else"]) && !$conditionTrue) {
            
            $result = $condition["else"];
            
        }
        
        return $result;
        
    }
    
}